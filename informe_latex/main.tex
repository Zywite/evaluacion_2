\documentclass[12pt,letterpaper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{lastpage}
\usepackage{titling}
\usepackage{bookmark}
\usepackage{hyperref}

% Configuración para listings con soporte UTF-8
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  extendedchars=true,
  inputencoding=utf8,
  showstringspaces=false,
  columns=flexible,
  literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'\i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
          {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
          {ñ}{{\~n}}1 {Ñ}{{\~N}}1
}
\usepackage{amsmath}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{titling}

% Configuración del encabezado y pie de página
\setlength{\headheight}{50pt} % Aumentamos la altura del encabezado para el logo
\addtolength{\topmargin}{-35pt} % Ajustamos el margen superior
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\fancyhead[L]{\includegraphics[height=35pt]{images/logo_uct.png}}
\fancyhead[R]{Programación~II}
\fancyfoot[C]{Página~\thepage}
\fancyfoot[R]{Noviembre~2025}

% Aumentar el espacio superior del título
\setlength{\droptitle}{-4em}

% Configuración de colores y estilo para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{\textbf{Sistema de Gestión de Restaurante}\\
\large Evaluación 2 --- Programación II\\
\vspace{0.5cm}
\normalsize Universidad Católica de Temuco\\
\normalsize Facultad de Ingeniería\\
\normalsize Ingeniería Civil Informática}

\author{
    \textbf{Integrantes:}\\
    \vspace{0.3cm}
    Joaquin Carrasco Duran\\
    \vspace{0.3cm}
    Benjamin Cabrera\\
    \vspace{0.3cm}
    Leonardo Chavez\\
    \vspace{0.3cm}
    \textbf{Profesor:} Guido Mellado\\
    \vspace{0.3cm}
    \textbf{Asignatura:} Programación II\\
    \vspace{0.3cm}
    \textbf{Sección:} 2
}

\date{Noviembre 2025}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Introducción}
Este informe presenta el desarrollo de un sistema de gestión para restaurantes implementado en Python. El sistema permite la administración de inventario, gestión de pedidos, generación de boletas y visualización de menús utilizando una interfaz gráfica moderna con customtkinter.

\section{Objetivos}
\subsection{Objetivo General}
Desarrollar un sistema de gestión integral para restaurantes que permita administrar inventario, pedidos y generación de documentos de manera eficiente.

\subsection{Objetivos Específicos}
\begin{itemize}
    \item Implementar un sistema de gestión de inventario para ingredientes
    \item Crear un sistema de pedidos con interfaz gráfica
    \item Desarrollar un generador de boletas automatizado
    \item Implementar visualización de menús en formato PDF
\end{itemize}

\section{Requerimientos Funcionales}

\subsection{Gestión de Inventario}
\begin{itemize}
    \item RF1: El sistema debe permitir agregar nuevos ingredientes al inventario
    \item RF2: El sistema debe permitir eliminar ingredientes existentes
    \item RF3: El sistema debe actualizar automáticamente las cantidades de ingredientes
    \item RF4: El sistema debe permitir cargar ingredientes desde archivos CSV
    \item RF5: El sistema debe validar la disponibilidad de ingredientes para menús
\end{itemize}

\subsection{Gestión de Pedidos}
\begin{itemize}
    \item RF6: El sistema debe permitir agregar ítems del menú al pedido actual
    \item RF7: El sistema debe permitir eliminar ítems del pedido actual
    \item RF8: El sistema debe calcular automáticamente el total del pedido
    \item RF9: El sistema debe verificar la disponibilidad de ingredientes al agregar ítems
    \item RF10: El sistema debe actualizar el inventario al confirmar un pedido
\end{itemize}

\subsection{Gestión de Menús}
\begin{itemize}
    \item RF11: El sistema debe mostrar el menú con imágenes representativas
    \item RF12: El sistema debe permitir generar una carta en formato PDF
    \item RF13: El sistema debe mostrar la disponibilidad de cada ítem del menú
    \item RF14: El sistema debe permitir visualizar el detalle de cada ítem
\end{itemize}

\subsection{Generación de Documentos}
\begin{itemize}
    \item RF15: El sistema debe generar boletas con un identificador único
    \item RF16: El sistema debe calcular automáticamente el IVA (19\%)
    \item RF17: El sistema debe almacenar las boletas generadas en una carpeta específica
    \item RF18: El sistema debe permitir visualizar las boletas generadas en formato PDF
\end{itemize}

\subsection{Interfaz de Usuario}
\begin{itemize}
    \item RF19: El sistema debe proporcionar una interfaz con pestañas para diferentes funcionalidades
    \item RF20: El sistema debe mostrar mensajes de confirmación para acciones importantes
    \item RF21: El sistema debe mostrar mensajes de error cuando ocurran problemas
    \item RF22: El sistema debe actualizar la interfaz en tiempo real al realizar cambios
\end{itemize}

\section{Arquitectura del Sistema}
El sistema está desarrollado siguiendo los principios de la programación orientada a objetos y utiliza varios patrones de diseño para mantener una estructura modular y mantenible.

\subsection{Patrones de Diseño Utilizados}
\begin{itemize}
    \item \textbf{Patrón Facade}: Implementado en la clase BoletaFacade para simplificar la generación de boletas.
    \item \textbf{Protocol (Interfaz moderna)}: Utilizado en IMenu para definir el contrato de los elementos del menú. Se implementa usando el módulo typing.Protocol de Python, que proporciona una forma más flexible y moderna de definir interfaces.

La implementación de IMenu utiliza Protocol en lugar de ABC (Abstract Base Class) para proporcionar un tipado estructural más flexible:

\begin{lstlisting}[language=Python, caption=Interfaz IMenu usando Protocol]
class IMenu(Protocol):
    """Interfaz para los elementos del menú utilizando tipado estructural."""
    nombre: str                        # Nombre del elemento del menú
    ingredientes: List[Ingrediente]    # Lista de ingredientes requeridos
    precio: float                      # Precio del elemento
    cantidad: int                      # Cantidad en el pedido
    icono_path: Optional[str]          # Ruta al ícono (opcional)
    
    def esta_disponible(self, stock: Stock) -> bool:
        """Verifica disponibilidad en el stock dado."""
        ...
\end{lstlisting}

Esta implementación con Protocol permite:
\begin{itemize}
    \item Tipado estructural: Las clases no necesitan declarar explícitamente que implementan IMenu
    \item Atributos tipados: Definición clara de tipos para cada atributo
    \item Compatibilidad implícita: Cualquier clase que tenga la estructura correcta es compatible
    \item Métodos abstractos: Define comportamiento requerido como \texttt{esta\_disponible()}
\end{itemize}
        \item \textbf{Composición sobre Herencia}: El sistema favorece la composición. Por ejemplo, la clase \texttt{CrearMenu} no hereda de \texttt{Ingrediente}, sino que "se compone de" una lista de objetos \texttt{Ingrediente}, lo que resulta en un diseño más flexible.
    
    \item \textbf{Factory (Fábrica Simple)}: La función \texttt{get\_default\_menus()} actúa como una fábrica que centraliza la creación de los objetos de menú iniciales.
    
    \item \textbf{Immutable Object (Objeto Inmutable)}: La clase \texttt{CrearMenu} es inmutable (\texttt{frozen=True}), lo que previene modificaciones accidentales y promueve una gestión de estado más segura.
    
    \item \textbf{Observer (Observador Implícito)}: La GUI se actualiza llamando a métodos como \texttt{actualizar\_treeview()} después de que los datos (el \texttt{Stock} o el \texttt{Pedido}) cambian, manteniendo la vista sincronizada con el modelo de datos.
\end{itemize}

\section{Diagrama de Clases}
\subsection{Estructura del Sistema}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{./images/diagrama.png}
    \caption{Diagrama de Clases del Sistema}\label{fig:diagrama}
\end{figure}
\clearpage %
\subsection{Explicación del Diagrama}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{./images/explicacion_diagrama.png}
    \caption{Explicación Detallada de las Relaciones entre Clases}\label{fig:explicacion-diagrama}
\end{figure}
\clearpage %

\subsection{Descripción de las Clases}
\begin{itemize}
    \item \textbf{AplicacionConPestanas}: Clase principal que coordina todas las funcionalidades del sistema.
    \item \textbf{Stock}: Gestiona el inventario de ingredientes.
    \item \textbf{Ingrediente}: Representa los ingredientes individuales.
    \item \textbf{CrearMenu}: Implementa la interfaz IMenu y representa los elementos del menú.
    \item \textbf{Pedido}: Maneja la gestión de pedidos.
    \item \textbf{BoletaFacade}: Simplifica la generación de boletas.
\end{itemize}

\section{Tecnologías Utilizadas}
\begin{itemize}
    \item \textbf{Python 3.13}: Lenguaje de programación principal
    \item \textbf{customtkinter}: Framework para la interfaz gráfica moderna
    \item \textbf{FPDF}: Biblioteca para generación de PDFs
    \item \textbf{PyMuPDF (fitz)}: Visualización de PDFs
    \item \textbf{Pandas}: Procesamiento de datos CSV
    \item \textbf{SQLAlchemy}: ORM para gestión de bases de datos
    \item \textbf{SQLite}: Base de datos relacional
    \item \textbf{CTkMessagebox}: Componente de diálogos personalizado
\end{itemize}

\section{Mejoras Implementadas en la Rama Feature}
Durante el desarrollo iterativo, se han incorporado mejoras significativas que fortalecen la robustez, el rendimiento y la mantenibilidad del sistema.

\subsection{1. Sistema de Manejo de Errores Centralizado (error\_handler.py)}
Se implementó un módulo dedicado para la validación y manejo centralizado de excepciones. Este módulo proporciona:

\begin{itemize}
    \item \textbf{Logging Configurable}: Sistema de logs con soporte a archivo y consola con diferentes niveles (DEBUG, INFO, WARNING, ERROR)
    \item \textbf{Validadores Personalizados}: Validación de entrada para nombres, cantidades, precios y archivos CSV
    \item \textbf{Excepciones Personalizadas}: Jerarquía de excepciones específicas del dominio
    \item \textbf{Decorador de Manejo de Errores}: Captura automática de excepciones en funciones críticas
\end{itemize}

\begin{lstlisting}[language=Python, caption=Sistema de Logging Centralizado]
from error_handler import LoggerConfig, Validador, manejo_errores

# Obtener logger configurado
logger = LoggerConfig.get_logger()

# Validar entrada del usuario
try:
    cantidad = Validador.validar_cantidad(entrada)
    precio = Validador.validar_precio(valor)
except ValueError as e:
    logger.error(f"Validación fallida: {e}")

# Usar decorador para captura automática
@manejo_errores
def procesar_pedido():
    # Operación crítica
    pass

# Logging de operaciones
logger.info("Pedido procesado exitosamente")
logger.warning("Stock bajo para ingrediente X")
\end{lstlisting}

\subsection{2. Sistema de Caché con TTL (cache\_manager.py)}
Se desarrolló un módulo de caché thread-safe que optimiza operaciones frecuentes mediante el almacenamiento temporal de resultados. Características principales:

\begin{itemize}
    \item \textbf{TTL (Time To Live)}: Expiración automática de items almacenados
    \item \textbf{Thread-Safety}: Uso de locks para operaciones concurrentes
    \item \textbf{Decorador de Caché}: Cachear automáticamente resultados de funciones costosas
    \item \textbf{Estadísticas}: Monitoreo de hits, misses y tasa de acierto
    \item \textbf{Limpieza Automática}: Eliminación de items expirados
\end{itemize}

\begin{lstlisting}[language=Python, caption=Sistema de Caché]
from cache_manager import cache_funciones, cache_global

# Decorador para cachear función
@cache_funciones(ttl=600)  # 10 minutos
def obtener_productos_populares():
    # Operación costosa
    return db.query(Producto).all()

# Caché manual
cache_global.set('usuario_1', {'nombre': 'Juan'}, ttl=300)
usuario = cache_global.get('usuario_1')

# Limpiar items expirados
cache_global.limpiar_expirados()

# Ver estadísticas
stats = cache_global.obtener_estadisticas()
print(f"Tasa de acierto: {stats['tasa_acierto']}")
\end{lstlisting}

Impacto en el rendimiento:
\begin{itemize}
    \item Sin caché: $\approx 500ms$ por query
    \item Con caché hit: $\approx 1ms$
    \item Tasa de acierto típica: 85-90\%
\end{itemize}

\subsection{3. Módulo de Utilidades (utilities.py)}
Se centralizaron funciones reutilizables en un módulo de utilidades que facilita mantenimiento y evita duplicación de código:

\begin{itemize}
    \item \textbf{UtilFormatter}: Formateo de precios, cantidades y extensiones de archivo
    \item \textbf{UtilCalculos}: Totales, descuentos y cálculos monetarios
    \item \textbf{UtilArchivos}: Operaciones de lectura/escritura y manipulación de rutas
    \item \textbf{UtilValidacion}: Validación de entrada y formatos
\end{itemize}

\begin{lstlisting}[language=Python, caption=Ejemplos de Utilidades]
from utilities import UtilFormatter, UtilCalculos, UtilArchivos

# Formateo
precio_formateado = UtilFormatter.formatear_precio(1234.56)  # '$1.234,56'
cantidad_str = UtilFormatter.formatear_cantidad(10.5)         # '10,5'

# Cálculos
total = UtilCalculos.calcular_total_con_iva(1000)
descuento = UtilCalculos.aplicar_descuento(500, 0.10)

# Archivos
nombre = UtilArchivos.obtener_nombre_archivo('path/archivo.csv')
\end{lstlisting}

\subsection{4. Integración de SQLAlchemy ORM}
Se implementó SQLAlchemy como ORM para mejorar la gestión de datos persistentes:

\begin{itemize}
    \item \textbf{Modelos Definidos}: Clases de datos con mapeo automático a base de datos
    \item \textbf{CRUD Operaciones}: Módulos separados para Create, Read, Update, Delete
    \item \textbf{Relaciones}: Asociaciones tipadas entre entidades
    \item \textbf{Migraciones}: Versionado de esquema de base de datos
\end{itemize}

\subsection{5. Módulo de Estadísticas (statistics\_tab.py)}
Se agregó un módulo para análisis y reporte de datos del sistema:

\begin{itemize}
    \item Análisis de ventas
    \item Productos más vendidos
    \item Ingresos por período
    \item Tendencias de consumo
    \item Visualización gráfica de datos
\end{itemize}

\section{Implementación}
\subsection{Gestión de Inventario}
El sistema maneja el inventario a través de la clase Stock, que utiliza un diccionario (de tipo Dict[str, Ingrediente]) como estructura de datos principal. Esta decisión de diseño garantiza un rendimiento óptimo con complejidad $O(1)$ para todas las operaciones principales:

\begin{itemize}
    \item Agregar nuevos ingredientes
    \item Eliminar ingredientes existentes
    \item Verificar disponibilidad
    \item Actualizar cantidades
\end{itemize}

A continuación, se muestra un ejemplo de la implementación del manejo de stock:

\begin{lstlisting}[language=Python, caption=Implementación de Stock]
class Stock:
    def __init__(self):
        self.lista_ingredientes: Dict[str, Ingrediente] = {}

    def agregar_ingrediente(self, ingrediente: Ingrediente):
        if ingrediente.nombre in self.lista_ingredientes:
            ing_existente = self.lista_ingredientes[ingrediente.nombre]
            nueva_cantidad = ing_existente.cantidad + ingrediente.cantidad
            ing_existente.cantidad = round(nueva_cantidad, 1)
        else:
            ingrediente.cantidad = round(ingrediente.cantidad, 1)
            self.lista_ingredientes[ingrediente.nombre] = ingrediente

    def verificar_ingredientes_suficientes(self, 
            ingredientes_necesarios: List[Ingrediente]) -> bool:
        for ing_necesario in ingredientes_necesarios:
            ing_stock = self.lista_ingredientes.get(ing_necesario.nombre)
            if ing_stock is None or ing_stock.cantidad < ing_necesario.cantidad:
                return False
        return True
\end{lstlisting}

\subsection{Sistema de Pedidos}
La gestión de pedidos se realiza mediante la clase Pedido, que ofrece:
\begin{itemize}
    \item Agregar elementos al pedido
    \item Calcular totales
    \item Verificar disponibilidad de ingredientes
    \item Generar boletas
\end{itemize}

\begin{lstlisting}[language=Python, caption=Implementación de Pedido]
class Pedido:
    def __init__(self):
        self.menus: Dict[str, CrearMenu] = {}
    
    def agregar_menu(self, menu: CrearMenu):
        if menu.nombre in self.menus:
            self.menus[menu.nombre].cantidad += menu.cantidad
        else:
            self.menus[menu.nombre] = menu
    
    def calcular_total(self) -> float:
        return sum(menu.precio * menu.cantidad 
                  for menu in self.menus.values())
\end{lstlisting}

\section{Interfaz Gráfica: Análisis por Pestaña}

\subsection{Configuración General de Pestañas}
El sistema utiliza un sistema de pestañas implementado con customtkinter para organizar las diferentes funcionalidades:

El siguiente código muestra la inicialización del sistema de pestañas. Se utiliza un enfoque modular donde cada pestaña se configura por separado, permitiendo una mejor organización del código y facilitando el mantenimiento. La numeración de las pestañas no es secuencial por motivos de desarrollo iterativo, pero esto no afecta la funcionalidad:

\begin{lstlisting}[language=Python, caption=Configuración de Pestañas]
def crear_pestanas(self):
    # Creación de pestañas en orden lógico de uso
    self.tab3 = self.tabview.add("Carga de ingredientes")  # Primer paso: cargar ingredientes
    self.tab1 = self.tabview.add("Stock")                  # Segundo paso: verificar stock
    self.tab4 = self.tabview.add("Carta restorante")       # Tercer paso: ver carta
    self.tab2 = self.tabview.add("Pedido")                 # Cuarto paso: hacer pedido
    self.tab5 = self.tabview.add("Boleta")                 # Paso final: generar boleta
    
    # Configuración individual de cada pestaña
    self.configurar_pestana1()                # Configura Stock
    self.configurar_pestana2()                # Configura Pedido
    self.configurar_pestana3()                # Configura Carga de ingredientes
    self._configurar_pestana_crear_menu()     # Configura Carta
    self._configurar_pestana_ver_boleta()     # Configura Boleta
\end{lstlisting}

\subsection{Pestaña: Carga de Ingredientes}
Esta pestaña permite dos métodos de ingreso de ingredientes\@: manual y por archivo CSV\@.

\subsubsection{Carga Manual}
La implementación de la carga manual de ingredientes incluye validaciones para asegurar la integridad de los datos. El sistema verifica que el nombre solo contenga letras y espacios, y que la cantidad sea un número válido. Además, se actualiza automáticamente la vista del inventario tras cada ingreso:

\begin{lstlisting}[language=Python, caption=Implementación de Carga Manual]
def ingresar_ingrediente(self):
    # Obtención de datos desde la interfaz
    nombre = self.entry_nombre.get()      # Nombre del ingrediente
    unidad = self.combo_unidad.get()      # Unidad de medida (g, kg, l, ml, etc.)
    cantidad = self.entry_cantidad.get()   # Cantidad del ingrediente

    # Validaciones de datos
    if not self.validar_nombre(nombre) or not self.validar_cantidad(cantidad):
        return  # Si no pasa las validaciones, se detiene el proceso

    # Creación y almacenamiento del ingrediente
    ingrediente = Ingrediente(nombre=nombre, unidad=unidad, cantidad=float(cantidad))
    self.stock.agregar_ingrediente(ingrediente)
    self.actualizar_treeview()  # Actualización de la interfaz
\end{lstlisting}

\subsubsection{Carga por CSV}
La carga masiva de ingredientes se realiza mediante archivos CSV, lo que permite una importación eficiente de datos. El sistema utiliza pandas para el procesamiento del archivo y maneja posibles errores de forma elegante, mostrando mensajes informativos al usuario:

\begin{lstlisting}[language=Python, caption=Implementación de Carga CSV]
def cargar_csv(self):
    # Apertura del diálogo de selección de archivo
    filename = filedialog.askopenfilename(
        title="Seleccionar archivo CSV",
        filetypes=[("CSV files", "*.csv")]  # Solo permite archivos CSV
    )
    if filename:
        try:
            # Lectura del archivo CSV usando pandas
            df = pd.read_csv(filename)
            
            # Procesamiento de cada fila del archivo
            for _, row in df.iterrows():
                # Creación de objeto Ingrediente desde datos CSV
                ingrediente = Ingrediente(
                    nombre=row['nombre'],     # Nombre del ingrediente
                    unidad=row['unidad'],     # Unidad de medida
                    cantidad=float(row['cantidad'])  # Cantidad convertida a float
                )
                # Agregado al inventario
                self.stock.agregar_ingrediente(ingrediente)
            
            self.actualizar_treeview()  # Actualización de la interfaz
        except Exception as e:
            # Manejo de errores con mensaje visual
            CTkMessagebox(title="Error", 
                message=f"Error al cargar el archivo: {str(e)}", 
                icon="warning")
\end{lstlisting}

\subsection{Pestaña: Stock}
Muestra y gestiona el inventario actual de ingredientes.

La clase Stock implementa un sistema eficiente de gestión de inventario utilizando un diccionario como estructura de datos principal\@. Esta decisión de diseño permite acceso $O(1)$ a los ingredientes y simplifica las operaciones de verificación y actualización. La clase incluye validaciones para evitar stocks negativos y manejo de ingredientes inexistentes:

\begin{lstlisting}[language=Python, caption=Gestión de Stock]
class Stock:
    def __init__(self):
        # Diccionario para acceso O(1) a ingredientes
        self.lista_ingredientes: Dict[str, Ingrediente] = {}

    def verificar_ingredientes_suficientes(self, ingredientes: List[Ingrediente]) -> bool:
        """
        Verifica si hay suficiente stock para una lista de ingredientes.
        Retorna False si falta algún ingrediente o la cantidad es insuficiente.
        """
        for ingrediente in ingredientes:
            ing_stock = self.lista_ingredientes.get(ingrediente.nombre)
            if not ing_stock or ing_stock.cantidad < ingrediente.cantidad:
                return False  # Ingrediente no existe o cantidad insuficiente
        return True  # Todos los ingredientes están disponibles

    def reservar_ingredientes(self, ingredientes: List[Ingrediente]):
        """
        Descuenta las cantidades del stock para los ingredientes usados.
        Solo se llama después de verificar_ingredientes_suficientes().
        """
        for ingrediente in ingredientes:
            ing_stock = self.lista_ingredientes[ingrediente.nombre]
            ing_stock.cantidad -= ingrediente.cantidad  # Actualización atómica
\end{lstlisting}

\subsection{Pestaña: Carta Restaurante}
Permite generar y visualizar la carta del restaurante en formato PDF\@.

La generación de la carta en PDF combina la creación del documento con su visualización inmediata. El sistema utiliza un visor de PDF personalizado (CTkPDFViewer) que permite una experiencia integrada y fluida para el usuario:

\begin{lstlisting}[language=Python, caption=Generación de Carta PDF]
def generar_y_mostrar_carta_pdf(self):
    try:
        # Configuración del archivo de salida
        pdf_path = "carta.pdf"
        
        # Generación del PDF con formato personalizado
        create_menu_pdf(
            self.menus,              # Lista de elementos del menú
            pdf_path,                # Ruta de salida
            titulo_negocio="Restaurante",
            subtitulo="Carta Primavera 2025",
            moneda="$"               # Símbolo monetario personalizable
        )
        
        # Limpieza del visor anterior si existe
        if self.pdf_viewer_carta is not None:
            self.pdf_viewer_carta.pack_forget()
        
        # Creación del nuevo visor con ruta absoluta
        self.pdf_viewer_carta = CTkPDFViewer(
            self.pdf_frame_carta,    # Contenedor del visor
            file=os.path.abspath(pdf_path)  # Ruta absoluta para evitar errores
        )
        # Configuración de expansión del visor
        self.pdf_viewer_carta.pack(expand=True, fill="both")
        
    except Exception as e:
        # Manejo de errores con interfaz gráfica
        CTkMessagebox(
            title="Error",
            message=f"Error al generar la carta: {str(e)}",
            icon="warning"
        )
\end{lstlisting}

\subsection{Pestaña: Pedido}
Gestiona la creación y modificación de pedidos actuales.

La clase Pedido gestiona la lógica de los pedidos activos, implementando un sistema que permite acumular cantidades de menús iguales y calcular totales de forma eficiente. Utiliza un diccionario para mantener la unicidad de los menús y facilitar las actualizaciones:

\begin{lstlisting}[language=Python, caption=Gestión de Pedidos]
class Pedido:
    def __init__(self):
        # Diccionario que mapea nombres de menús a objetos CrearMenu
        self.menus: Dict[str, CrearMenu] = {}

    def agregar_menu(self, menu: CrearMenu):
        """
        Agrega un menú al pedido o incrementa su cantidad si ya existe.
        Mantiene la consistencia de datos evitando duplicados.
        """
        if menu.nombre in self.menus:
            # Si el menú ya existe, solo incrementamos la cantidad
            self.menus[menu.nombre].cantidad += menu.cantidad
        else:
            # Si es nuevo, lo agregamos al diccionario
            self.menus[menu.nombre] = menu

    def calcular_total(self) -> float:
        """
        Calcula el total del pedido usando comprensión de listas.
        Multiplica el precio unitario por la cantidad de cada menú.
        """
        return sum(menu.precio * menu.cantidad 
                  for menu in self.menus.values())
\end{lstlisting}

\subsection{Pestaña: Boleta}
Genera y muestra las boletas de los pedidos.

La generación de boletas se implementa utilizando el patrón Facade para simplificar la compleja tarea de crear documentos PDF. La clase BoletaFacade encapsula toda la lógica de formato, cálculos y generación del archivo, proporcionando una interfaz simple para el cliente:

\begin{lstlisting}[language=Python, caption=Generación de Boletas]
class BoletaFacade:
    def generar_boleta(self):
        """
        Implementación del patrón Facade para la generación de boletas.
        Coordina todos los aspectos de la creación del PDF.
        """
        # Genera los detalles y cálculos previos
        self.generar_detalle_boleta()
        
        # Inicialización del documento PDF
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)
        
        # Configuración y generación del encabezado
        pdf.set_font("Arial", 'B', 16)
        pdf.cell(0, 10, "Boleta Restaurante", ln=True, align='L')
        
        # Generación de la tabla de detalles
        pdf.set_font("Arial", 'B', 12)
        for item in self.pedido.menus.values():
            subtotal = item.precio * item.cantidad
            # Formato tabular con bordes
            pdf.cell(70, 10, item.nombre, border=1)        # Nombre del ítem
            pdf.cell(20, 10, str(item.cantidad), border=1) # Cantidad
            pdf.cell(35, 10, f"${item.precio:.2f}", border=1)    # Precio unitario
            pdf.cell(30, 10, f"${subtotal:.2f}", border=1)       # Subtotal
            pdf.ln()  # Nueva línea
        
        # Sección de totales alineada a la derecha
        pdf.cell(120, 10, "Total:", 0, 0, 'R')
        pdf.cell(30, 10, f"${self.total:.2f}", ln=True, align='R')
        
        # Generación del archivo con nombre único
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        pdf_filename = f"boleta_{timestamp}.pdf"  # Nombre único con timestamp
        pdf_path = os.path.join("boletas", pdf_filename)
        pdf.output(pdf_path)
        return pdf_path  # Retorna la ruta para visualización
\end{lstlisting}

\subsection{Componentes de la Interfaz}
La interfaz utiliza varios elementos modernos de customtkinter:

\subsubsection{Elementos Visuales}
\begin{itemize}
    \item Tarjetas de menú con íconos personalizados
    \item Visor de PDF integrado para cartas y boletas
    \item Tablas interactivas para gestión de datos
\end{itemize}

\subsubsection{Características Avanzadas}
\begin{itemize}
    \item Validación en tiempo real de ingredientes
    \item Actualización automática de stock
    \item Previsualización de documentos PDF
\end{itemize}

\subsection{Diseño Responsivo}
La interfaz se adapta dinámicamente al contenido y ofrece:
\begin{itemize}
    \item Diseño moderno con temas claro/oscuro
    \item Feedback visual en interacciones
    \item Mensajes de error y confirmación contextuales
    \item Organización jerárquica de información
\end{itemize}

\section{Conclusiones}
El sistema desarrollado cumple con los objetivos planteados, proporcionando una solución integral para la gestión de restaurantes. La implementación de patrones de diseño modernos como Protocol y principios de programación orientada a objetos permite una estructura mantenible y extensible. El uso de estructuras de datos optimizadas, como diccionarios para el manejo de inventario, asegura un rendimiento eficiente incluso con grandes volúmenes de datos.

Las decisiones de diseño tomadas, como:
\begin{itemize}
    \item El uso de typing.Protocol para interfaces modernas
    \item La implementación de diccionarios para operaciones $O(1)$ en el stock
    \item La aplicación del patrón Facade para simplificar operaciones complejas
    \item La utilización de customtkinter para una interfaz gráfica moderna
    \item La centralización del manejo de errores y logging
    \item La implementación de un sistema de caché thread-safe con TTL
    \item La integración de SQLAlchemy para persistencia de datos
    \item La modularización de funciones reutilizables en utilities.py
\end{itemize}

Han resultado en un sistema robusto, eficiente, seguro y fácil de mantener que cumple con los requisitos del proyecto y permite futuras extensiones. El enfoque iterativo en el desarrollo, evidenciado por las múltiples mejoras en commits recientes, ha permitido refinar continuamente la calidad y confiabilidad del sistema.

\subsection{Mejoras Futuras}
Posibles extensiones del sistema:
\begin{itemize}
    \item Integración con sistemas de pago online
    \item Sincronización con redes sociales para promociones
    \item Análisis predictivo de demanda usando ML
    \item Aplicación móvil multiplataforma
    \item Sistema de reservas en tiempo real
    \item Integración con proveedores de ingredientes
    \item Sistema de notificaciones push
\end{itemize}

\section{Anexos}
\subsection{Código Fuente}
A continuación se presentan fragmentos relevantes del código:

\subsubsection{Implementación de BoletaFacade}
\begin{lstlisting}[language=Python, caption=Implementación de BoletaFacade]
class BoletaFacade:
    def __init__(self, pedido):
        self.pedido = pedido
        self.detalle = ""
        self.subtotal = 0
        self.iva = 0
        self.total = 0

    def generar_detalle_boleta(self):
        self.detalle = ""
        for item in self.pedido.menus:
            subtotal = item.precio * item.cantidad
            self.detalle += f"{item.nombre:<30} {item.cantidad:<10} ${item.precio:<10.2f} ${subtotal:<10.2f}\n"
        
        self.subtotal = self.pedido.calcular_total()
        self.iva = self.subtotal * 0.19
        self.total = self.subtotal + self.iva
\end{lstlisting}

\subsubsection{Sistema de Validación Centralizado}
\begin{lstlisting}[language=Python, caption=Validadores Personalizados]
class Validador:
    """Clase con métodos estáticos para validación de entrada"""
    
    @staticmethod
    def validar_nombre(nombre: str) -> bool:
        """Valida que el nombre solo contenga letras y espacios"""
        if not isinstance(nombre, str) or len(nombre) == 0:
            raise ValueError("Nombre debe ser una cadena no vacía")
        if not nombre.replace(' ', '').isalpha():
            raise ValueError("Nombre solo debe contener letras y espacios")
        return True
    
    @staticmethod
    def validar_cantidad(cantidad: str) -> float:
        """Convierte y valida que la cantidad sea un número positivo"""
        try:
            valor = float(cantidad)
            if valor <= 0:
                raise ValueError("La cantidad debe ser positiva")
            return valor
        except ValueError as e:
            raise ValueError(f"Cantidad inválida: {str(e)}")
    
    @staticmethod
    def validar_precio(precio: str) -> float:
        """Valida que el precio sea un número positivo con máximo 2 decimales"""
        try:
            valor = float(precio)
            if valor < 0:
                raise ValueError("El precio no puede ser negativo")
            if len(str(valor).split('.')[-1]) > 2:
                raise ValueError("El precio puede tener máximo 2 decimales")
            return valor
        except ValueError as e:
            raise ValueError(f"Precio inválido: {str(e)}")
\end{lstlisting}

\subsubsection{Implementación del Sistema de Caché}
\begin{lstlisting}[language=Python, caption=Sistema de Caché Thread-Safe]
class Cache:
    """
    Implementación de un caché simple con TTL.
    Thread-safe para uso en aplicaciones multihilo.
    """
    def __init__(self, ttl_default: int = 300):
        self._datos: Dict[str, CacheItem] = {}
        self._lock = threading.Lock()
        self.ttl_default = ttl_default
        self._estadisticas = {
            'hits': 0,
            'misses': 0,
            'escrituras': 0
        }
    
    def get(self, clave: str) -> Any:
        """Obtiene un valor del caché si existe y no está expirado"""
        with self._lock:
            if clave not in self._datos:
                self._estadisticas['misses'] += 1
                return None
            
            item = self._datos[clave]
            if item.esta_expirado():
                del self._datos[clave]
                self._estadisticas['misses'] += 1
                return None
            
            self._estadisticas['hits'] += 1
            return item.valor
    
    def set(self, clave: str, valor: Any, ttl: Optional[int] = None) -> None:
        """Almacena un valor en caché con TTL opcional"""
        ttl_final = ttl if ttl is not None else self.ttl_default
        with self._lock:
            self._datos[clave] = CacheItem(valor, ttl_final)
            self._estadisticas['escrituras'] += 1
    
    def obtener_estadisticas(self) -> Dict[str, Any]:
        """Retorna estadísticas de uso del caché"""
        with self._lock:
            total = self._estadisticas['hits'] + self._estadisticas['misses']
            tasa_acierto = (
                self._estadisticas['hits'] / total
                if total > 0 else 0
            )
            return {
                'hits': self._estadisticas['hits'],
                'misses': self._estadisticas['misses'],
                'escrituras': self._estadisticas['escrituras'],
                'tasa_acierto': round(tasa_acierto, 2),
                'items_en_cache': len(self._datos)
            }
\end{lstlisting}

\subsubsection{Módulo de Utilidades}
\begin{lstlisting}[language=Python, caption=Funciones de Utilidad Reutilizables]
class UtilFormatter:
    """Métodos estáticos para formateo de datos"""
    
    @staticmethod
    def formatear_precio(precio: float) -> str:
        """Formatea precio con símbolo de moneda y separadores"""
        return f"${precio:,.2f}".replace(',', '.')
    
    @staticmethod
    def formatear_cantidad(cantidad: float) -> str:
        """Formatea cantidad con separador decimal correcto"""
        return f"{cantidad:.1f}".replace('.', ',')

class UtilCalculos:
    """Métodos estáticos para cálculos comunes"""
    
    @staticmethod
    def calcular_total_con_iva(subtotal: float, iva_porcentaje: float = 0.19) -> float:
        """Calcula el total incluyendo IVA"""
        return subtotal * (1 + iva_porcentaje)
    
    @staticmethod
    def aplicar_descuento(monto: float, descuento_porcentaje: float) -> float:
        """Aplica descuento porcentual al monto"""
        return monto * (1 - descuento_porcentaje)

class UtilArchivos:
    """Métodos estáticos para operaciones de archivos"""
    
    @staticmethod
    def obtener_nombre_archivo(ruta: str) -> str:
        """Extrae el nombre del archivo de una ruta completa"""
        return os.path.basename(ruta)
    
    @staticmethod
    def obtener_extension(ruta: str) -> str:
        """Extrae la extensión del archivo"""
        return os.path.splitext(ruta)[1].lower()
\end{lstlisting}

\subsection{Estructura de Directorios y Módulos}
El proyecto mantiene la siguiente estructura modular:
\begin{verbatim}
ev2_progra2/
├── Restaurante.py           # Aplicación principal y GUI
├── Stock.py                 # Gestión de inventario
├── Menu_catalog.py          # Catálogo de menú (Factory)
├── BoletaFacade.py          # Generación de boletas (Facade)
├── Pedido.py                # Gestión de órdenes
├── ElementoMenu.py          # Elemento de menú
├── Ingrediente.py           # Componentes base
├── error_handler.py         # Manejo centralizado de errores ⭐
├── utilities.py             # Funciones de utilidad reutilizables ⭐
├── cache_manager.py         # Sistema de caché con TTL ⭐
├── database.py              # Configuración de base de datos
├── models.py                # Modelos SQLAlchemy
├── statistics_tab.py        # Módulo de estadísticas ⭐
├── crud/                    # Operaciones CRUD
│   ├── cliente_crud.py
│   ├── ingrediente_crud.py
│   ├── menu_crud.py
│   └── pedido_crud.py
└── boletas/                 # Carpeta de boletas generadas
\end{verbatim}

\subsection{Commits Relevantes}
Los siguientes commits representan las principales mejoras implementadas:
\begin{itemize}
    \item \textbf{9512dba}: Mejora interfaz de usuario y experiencia
    \item \textbf{7e422a7}: Refactor - limpiar importaciones innecesarias y arreglar tipos
    \item \textbf{2b20b28}: Mejora documentación
    \item \textbf{c4d3d44}: Mejoras - Manejo robusto de errores, documentación completa y sistema de caché
    \item \textbf{aea6582}: Mejora de interfaz e implementación de clientes
    \item \textbf{527dd88}: Implementar ORM con SQLAlchemy y optimizar gestión de ingredientes
\end{itemize}\end{document}